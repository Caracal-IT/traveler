# Named Pipes

Named pipes, also known as FIFOs (First In, First Out), are a type of inter-process communication 
mechanism in Unix-like operating systems. They allow data to be passed between processes   
in a sequential manner, similar to how data flows through a pipe in a plumbing system. Named pipes   
are created with the `mkfifo` command and can be used for communication between different processes,  
enabling them to exchange data in a synchronized manner.

## Creating a Named Pipe

To create a named pipe, use the `mkfifo` command followed by the desired name for the pipe:

```bash
mkfifo -m 0666 my_pipe
```

This command creates a named pipe named `my_pipe` that can be used for inter-process communication.  
The `-m 0666` option specifies the permissions for the pipe, allowing read and write access for all users.

## Reading from a Named Pipe

To read from a named pipe, you can use the `cat` command or any other command that reads from standard input. For example:

```bash
cat < my_pipe
```

This command reads data from the `my_pipe` named pipe and displays it on the terminal.

```bash 
tail -f my_pipe
```

```bash
while true; do cat my_pipe; sleep 0.1; done
```

## Writing to a Named Pipe

To write to a named pipe, use the `echo` command followed by the data to be written: 

```bash
echo "Hello, world!" > my_pipe
```

This command writes the string "Hello, world!" to the `my_pipe` named pipe, allowing other processes   
to read it.

```bash
echo "Generating random numbers (0-32767):" && while true; do num=$RANDOM; echo $num; echo $num > my_pipe; sleep 1; done
echo "Generating random integers (1-100):" && while true; do num=$((RANDOM % 100 + 1)); echo $num; echo $num > my_pipe; sleep 1; done
echo "Generating random floating-point (0.1-10.0):" && while true; do num=$(echo "scale=2; $(shuf -i 1-100 -n 1)/10" | bc); echo $num; echo $num > my_pipe; sleep 1; done
```

These commands generate random numbers and write them to the `my_pipe` named pipe, enabling real-time   
data exchange between processes.

The first command generates random numbers and writes them to the pipe, allowing processes to receive   
random values at regular intervals. 

The second command generates random integers between 1 and 100 and writes them to the pipe, allowing   
processes to receive random integers at regular intervals.

The third command generates random floating-point numbers between 0 and 10 and writes them to the pipe,   
allowing processes to receive random decimal values at regular intervals.

The `shuf` command is used to shuffle the output of a command.   
The `-i` option, it specifies the range of values to generate.   
The `-n 1` option specifies that only one value should be generated.   
The `bc` command is used to perform arbitrary precision arithmetic.   
The `scale=2` option sets the number of decimal places to 2, ensuring that the generated floating-point   
numbers have two decimal places.

## Go Implementation

### Producer

A Go producer that writes random numbers to a named pipe:

```go
package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	pipeName := "my_pipe"

	// Open the named pipe for writing
	pipe, err := os.OpenFile(pipeName, os.O_WRONLY, os.ModeNamedPipe)
	if err != nil {
		log.Fatalf("Failed to open pipe: %v", err)
	}
	defer func(pipe *os.File) {
		_ = pipe.Close()
	}(pipe)

	// Setup signal handling for Ctrl+C
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	fmt.Println("Generating random numbers (0-100):")

	// Create a ticker for regular intervals
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-sigChan:
			fmt.Println("\nStopping producer...")
			return
		case <-ticker.C:
			num := rand.Intn(101) // Random number between 0-100
			fmt.Printf("Sending: %d\n", num)

			_, err := fmt.Fprintf(pipe, "%d\n", num)
			if err != nil {
				log.Printf("Error writing to pipe: %v", err)
				return
			}
		}
	}
}
```

**Usage:**

1. Create the named pipe first:
   ```bash
   mkfifo my_pipe
   ```

2. Run the Go producer:
   ```bash
   go run producer.go
   ```

3. In another terminal, read from the pipe:
   ```bash
   cat my_pipe
   ```

Press Ctrl+C to stop the producer.

### Consumer

A Go consumer that reads from a named pipe:

```go
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
)

func main() {
	pipeName := "my_pipe"

	// Setup signal handling for Ctrl+C
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	fmt.Println("Reading from pipe...")

	go func() {
		// Open the named pipe for reading
		pipe, err := os.OpenFile(pipeName, os.O_RDONLY, os.ModeNamedPipe)
		if err != nil {
			log.Fatalf("Failed to open pipe: %v", err)
		}
		defer func(pipe *os.File) {
			_ = pipe.Close()
		}(pipe)

		scanner := bufio.NewScanner(pipe)
		for scanner.Scan() {
			line := scanner.Text()
			fmt.Printf("Received: %s\n", line)
		}

		if err := scanner.Err(); err != nil {
			log.Printf("Error reading from pipe: %v", err)
		}
	}()

	// Wait for the interrupt signal
	<-sigChan
	fmt.Println("\nStopping consumer...")
}
```

**Usage:**

1. Make sure the named pipe exists:
   ```bash
   mkfifo my_pipe
   ```

2. Run the Go consumer:
   ```bash
   go run consumer.go
   ```

3. In another terminal, write to the pipe (can use the producer or shell commands)

Press Ctrl+C to stop the consumer.
