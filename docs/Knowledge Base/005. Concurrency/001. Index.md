# Concurrency

## Introduction

Go provides first-class support for concurrent programming through goroutines and channels.   
Goroutines are lightweight threads managed by the Go runtime that allow functions to run   
concurrently with minimal overhead, making it possible to spawn thousands or even millions   
of them efficiently. Channels facilitate safe communication between goroutines by passing   
data without shared memory, following the principle "Don't communicate by sharing memory;   
share memory by communicating." This concurrency model, combined with the `select`   
statement for multiplexing channel operations, makes Go particularly well-suited for   
building scalable network services, parallel processing systems, and applications that need   
to handle many simultaneous operations.

## Concurrency vs Parallelism

Concurrency and parallelism are related but distinct concepts. Concurrency is about dealing   
with multiple tasks at once by structuring a program to handle many things simultaneously,   
such as interleaving execution through context switching—it's about composition and design.   
Parallelism, on the other hand, is about doing multiple tasks at the same time by executing   
them simultaneously on multiple CPU cores—it's about execution. Go's concurrency primitives   
(goroutines and channels) enable concurrent design, and when running on multi-core systems,   
the Go runtime can execute goroutines in parallel, but a concurrent program doesn't require   
parallel execution to be effective.


