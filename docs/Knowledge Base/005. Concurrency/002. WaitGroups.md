# WaitGroups

## Introduction

A WaitGroup in Go provides a simple way to wait for a collection of goroutines to finish executing   
before proceeding. It works like a counter: you call `Add(n)` to increment the counter by the   
number of goroutines you're launching, each goroutine calls `Done()` when it completes   
(decrementing the counter), and the main goroutine calls `Wait()` to block until the counter   
reaches zero. This pattern is essential for coordinating concurrent work without race conditions   
or premature program termination, ensuring that all spawned goroutines have completed their tasks   
before the program exits or moves to the next phase of execution.

## Example

### Without WaitGroups

The program below will finish executing before the functions are completed.  

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go func() {
		fmt.Println("Hello from goroutine 1")
		time.Sleep(1 * time.Second)
	}()

	go func() {
		fmt.Println("Hello from goroutine 2")
		time.Sleep(1 * time.Second)
	}()
}
```

### With WaitGroups

The program below will wait for the functions to complete before exiting.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		fmt.Println("Hello from goroutine 1")
		time.Sleep(1 * time.Second)
		wg.Done()
	}()

	go func() {
		fmt.Println("Hello from goroutine 2")
		time.Sleep(1 * time.Second)
		wg.Done()
	}()
	
	wg.Wait()
}
```

